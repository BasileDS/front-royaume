/**
 * Simple script to generate TypeScript types from Directus using the SDK
 * This fetches data from collections to infer types
 * 
 * Usage: node scripts/generate-directus-types-simple.mjs
 */

import { createDirectus, rest, readItems } from '@directus/sdk';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DIRECTUS_URL = process.env.EXPO_PUBLIC_DIRECTUS_URL || process.env.NEXT_PUBLIC_DIRECTUS_URL || 'https://paraiges-directus.neodelta.dev';
const OUTPUT_FILE = path.join(__dirname, '../../../src/shared/types/directus-generated.ts');

// Collections to fetch (add your collection names here)
const COLLECTIONS = [
  'beers',
  'breweries',
  'establishments',
  'news',
  'quests',
  'styles',
  'beers_establishments',
  'news_establishments',
  'level_thresholds'
];

/**
 * Create Directus client (public access)
 */
const client = createDirectus(DIRECTUS_URL).with(rest());

/**
 * Convert collection name to PascalCase interface name
 */
function toPascalCase(str) {
  return str
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

/**
 * Infer TypeScript type from value
 */
function inferType(value) {
  if (value === null || value === undefined) return 'any';
  
  const type = typeof value;
  if (type === 'number') return 'number';
  if (type === 'string') return 'string';
  if (type === 'boolean') return 'boolean';
  if (Array.isArray(value)) {
    if (value.length === 0) return 'any[]';
    return `${inferType(value[0])}[]`;
  }
  if (type === 'object') return 'any';
  
  return 'any';
}

/**
 * Generate interface from sample data
 */
function generateInterface(collectionName, sampleItem) {
  const interfaceName = toPascalCase(collectionName);
  
  let output = `/**\n * ${collectionName} collection\n */\n`;
  output += `export interface ${interfaceName} {\n`;
  
  if (sampleItem) {
    for (const [key, value] of Object.entries(sampleItem)) {
      const type = inferType(value);
      output += `  ${key}?: ${type};\n`;
    }
  }
  
  output += '}\n\n';
  
  return output;
}

/**
 * Main function
 */
async function generateTypes() {
  try {
    console.log(`🔍 Fetching sample data from ${DIRECTUS_URL}...`);
    
    let output = `/**
 * Auto-generated TypeScript types for Directus collections
 * Generated from: ${DIRECTUS_URL}
 * Generated at: ${new Date().toISOString()}
 * 
 * Generated by fetching sample data from each collection
 * Run 'npm run directus:types' to regenerate
 */

`;
    
    const collectionData = {};
    
    // Fetch sample from each collection
    for (const collection of COLLECTIONS) {
      try {
        console.log(`  📝 Fetching ${collection}...`);
        const items = await client.request(
          readItems(collection, {
            limit: 1,
            fields: ['*']
          })
        );
        
        collectionData[collection] = items[0] || {};
        output += generateInterface(collection, items[0]);
      } catch (error) {
        console.warn(`  ⚠️  Could not fetch ${collection}: ${error.message}`);
        output += generateInterface(collection, {});
      }
    }
    
    // Generate DirectusSchema type
    output += '/**\n * Directus Schema - Mapping of collection names to their types\n */\n';
    output += 'export interface DirectusSchema {\n';
    COLLECTIONS.forEach(collection => {
      const interfaceName = toPascalCase(collection);
      output += `  ${collection}: ${interfaceName}[];\n`;
    });
    output += '}\n';
    
    // Write to file
    fs.writeFileSync(OUTPUT_FILE, output, 'utf8');
    
    console.log(`✅ Types generated successfully!`);
    console.log(`📄 Output: ${OUTPUT_FILE}`);
    console.log(`\n💡 Note: These types are inferred from sample data.`);
    console.log(`   For production use, manually review and enhance the generated types.`);
    
  } catch (error) {
    console.error('❌ Error generating types:', error);
    process.exit(1);
  }
}

// Run the script
generateTypes();
